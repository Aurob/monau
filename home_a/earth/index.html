<!DOCTYPE html>
<html>
    <head>
        <style>
            html, body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
            }

            canvas {
                display: block;
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
<body>
    <script src="https://threejs.org/build/three.min.js"></script>

    <script>
        // scene
        var scene = new THREE.Scene();
        var imgsize = '';
        var urlparams = new URLSearchParams(window.location.search);
        if (urlparams.has('s')) {
            imgsize = urlparams.get('s');
            if (imgsize != '10k') {
                imgsize = '';
            }
        }

        // camera
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.set(0, 0, 15);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        // renderer
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // light
        var light = new THREE.PointLight(0xffffff, 300, 1000 ); 
        light.position.set( -15, 0, 10 ); 
        scene.add(light);

        // sphere geometry
        var geometry = new THREE.SphereGeometry(5, 32, 32);
        // var material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
        // earth.jpg texture
        var material = new THREE.MeshPhongMaterial({
            map: new THREE.TextureLoader().load(`earth${imgsize}.jpg`),
            bumpMap: new THREE.TextureLoader().load(`earthbump${imgsize}.jpg`),
            // map: new THREE.TextureLoader().load('earth10k.jpg'),
            // bumpMap: new THREE.TextureLoader().load('earthbump10k.jpg'),
            bumpScale: 0.05
        });

        // sphere object
        var sphere = new THREE.Mesh(geometry, material);

        // rotate 23.5 degrees
        sphere.rotation.x = 23.5 * Math.PI / 180;

        scene.add(sphere);

        var spGeometry = new THREE.SphereGeometry(.1,40,40);
        var spMaterial = new THREE.MeshBasicMaterial({color: 0x0000FF});
        var spSphere = new THREE.Mesh(spGeometry, spMaterial);
        scene.add(spSphere);
        
        var mouse = new THREE.Vector2();
        var mousemoving = false;
        // render
        var render = function () {
            requestAnimationFrame(render);
            renderer.render(scene, camera);

            // rotate the sphere at a rate of 1 full rotation per minute
            sphere.rotation.y += 2 * Math.PI / (60 * 60);

            // if (mousemoving) {
            //     spSphere.position.x = 0;
            //     spSphere.position.y = 0;
            //     spSphere.position.z = 0;
            //     mousemoving = false;
            // }
        };

        var raycaster = new THREE.Raycaster();
        var onMouseMove = function (e) {
        
            mousemoving = true;
            // calculate mouse position in normalized device coordinates
            // (-1 to +1) for both components
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (e.clientY / window.innerHeight) * 2 + 1;

            // update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects(scene.children);

            for (var i = 0; i < intersects.length; i++) {
                spSphere.position.x = intersects[i].point.x;
                spSphere.position.y = intersects[i].point.y;
                spSphere.position.z = intersects[i].point.z;
            }
        }

        window.addEventListener('mousemove', onMouseMove, false);
        render();
    </script>
</body>
</html>