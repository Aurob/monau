<!DOCTYPE html>
<html>
    <head>
        <style>
            html, body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
            }

            canvas {
                display: block;
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
<body>
    <script src="https://threejs.org/build/three.min.js"></script>

    <script>
        // scene
        var scene = new THREE.Scene();
        var imgsize = '';
        var urlparams = new URLSearchParams(window.location.search);
        if (urlparams.has('s')) {
            imgsize = urlparams.get('s');
            if (imgsize != '10k') {
                imgsize = '';
            }
        }

        // camera
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.set(0, 0, 13.099999999999985);
        // quick move in z direction using w and s
        document.addEventListener('keydown', function (e) {
            if (e.key == 'w') {
                camera.position.z -= 0.1;
            } else if (e.key == 's') {
                camera.position.z += 0.1;
            }
        });
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        // renderer
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // light
        // var light = new THREE.PointLight(0xffffff, 10, 10 ); 
        var light = new THREE.SpotLight(0xffffff, 100, 2000, Math.PI / 6, 1);
        light.position.set( -15, 0, 10 ); 
        scene.add(light);

        // sphere geometry
        var geometry = new THREE.SphereGeometry(5, 32, 32);
        // var material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
        // earth.jpg texture
        var material = new THREE.MeshPhongMaterial({
            map: new THREE.TextureLoader().load(`earth${imgsize}.jpg`),
            bumpMap: new THREE.TextureLoader().load(`earthbump${imgsize}.jpg`),
            // map: new THREE.TextureLoader().load('earth10k.jpg'),
            // bumpMap: new THREE.TextureLoader().load('earthbump10k.jpg'),
            bumpScale: 0.05
        });

        // sphere object
        var sphere = new THREE.Mesh(geometry, material);

        // rotate 23.5 degrees
        sphere.rotation.x = 23.5 * Math.PI / 180;

        scene.add(sphere);

        var spGeometry = new THREE.SphereGeometry(.1,40,40);
        var spMaterial = new THREE.MeshBasicMaterial({color: 0x0000FF});
        var spSphere = new THREE.Mesh(spGeometry, spMaterial);
        scene.add(spSphere);
        
        var mouse = new THREE.Vector2();
        var mousemoving = false;
        var tick = 0;
        var espeed = 2;
        // render
        var render = function () {
            requestAnimationFrame(render);
            renderer.render(scene, camera);

            // rotate the sphere at a rate of 1 full rotation per minute
            sphere.rotation.y += espeed * Math.PI / (60 * 60);

            // if (mousemoving) {
            //     spSphere.position.x = 0;
            //     spSphere.position.y = 0;
            //     spSphere.position.z = 0;
            //     mousemoving = false;
            // }

            // Set the light to point at the position of the small sphere
            // but point it in the opposite direction
            // light.position.set(spSphere.position.x, spSphere.position.y, spSphere.position.z);
            // light.position.multiplyScalar(1.1);
            tick++;
        };

        var raycaster = new THREE.Raycaster();
        var onMouseMove = function (e) {
        
            mousemoving = true;
            // calculate mouse position in normalized device coordinates
            // (-1 to +1) for both components
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (e.clientY / window.innerHeight) * 2 + 1;

            // update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects(scene.children);

            for (var i = 0; i < intersects.length; i++) {
                // spSphere.position.x = intersects[i].point.x;
                // spSphere.position.y = intersects[i].point.y;
                // spSphere.position.z = intersects[i].point.z;

                // move the sphere at a point halfway between the camera and the intersection point
                spSphere.position.x = (intersects[i].point.x + camera.position.x) / 2;
                spSphere.position.y = (intersects[i].point.y + camera.position.y) / 2;
                spSphere.position.z = (intersects[i].point.z + camera.position.z) / 2;
            }
        }

        // window.addEventListener('mousemove', onMouseMove, false);
        render();
    </script>
</body>
</html>