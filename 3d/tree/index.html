<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAU</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
    <script>
        function getRandomConeSurfacePoint(radius, height) {
            const theta = Math.random() * Math.PI * 2;   // Random angle
            const h = Math.random() * height;            // Random height
            const r = radius * (h / height);             // Radius at height h

            // Convert polar to Cartesian coordinates
            const x = r * Math.cos(theta);
            const y = r * Math.sin(theta);
            const z = h - height / 2;                    // Adjust z based on cone's center

            return new THREE.Vector3(x, y, z);
        }

        function isPositionOutsideCone(point, coneGeometry, conePosition, coneQuaternion) {
            // Create a THREE.Vector3 representing the point's position relative to the cone's apex
            const relativePosition = new THREE.Vector3().subVectors(point, conePosition);
            // Apply the inverse of the cone's quaternion to align with the cone's local space
            relativePosition.applyQuaternion(coneQuaternion.clone().invert());

            // Calculate the distance of the point from the cone's axis (assuming the axis runs along the y-coordinate)
            const distanceFromAxis = new THREE.Vector2(relativePosition.x, relativePosition.z).length();

            // Since the cone is assumed to be aligned along the y axis in its local space, calculate its height from the tip
            const pointHeight = coneGeometry.parameters.height - relativePosition.y;

            // If the pointHeight is negative, the point is below the cone's height and thus outside
            if (pointHeight < 0 || pointHeight > coneGeometry.parameters.height) {
                return true;
            }

            // The maximum radius of the cone at pointHeight
            const maxRadiusAtHeight = (pointHeight / coneGeometry.parameters.height) * coneGeometry.parameters.radius;

            // Check if the point's distance is greater than the maximum radius at that height
            return distanceFromAxis > maxRadiusAtHeight;
        }

        function getRandomPositionInCone(coneGeometry, conePosition, coneQuaternion) {
            const radius = coneGeometry.parameters.radius;
            const height = coneGeometry.parameters.height;
            // Get a uniformly distributed random height within the cone
            const h = Math.cbrt(Math.random()) * height;
            // Calculate the corresponding radius at that height
            const maxRadius = (h / height) * radius;

            // Uniformly distributed angle around the cone
            const theta = Math.random() * Math.PI * 2;

            // Random radius from 0 to maxRadius
            const r = maxRadius * Math.sqrt(Math.random());

            // Convert polar coordinates (r, theta) to Cartesian coordinates (x, z) in the cone's base plane
            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);

            // Create vector for local position within the cone
            // Assuming the cone's vertex is at the origin and it extends in the -y direction when unrotated
            const localPosition = new THREE.Vector3(x, -h, z); // -h because we flip the cone like a pyramid

            localPosition.y += height;
            return localPosition;
        }

        // function getRadiusAtHeight(height, coneGeometry) {
        //     return coneGeometry.parameters.radius - ((height / coneGeometry.parameters.height) * coneGeometry.parameters.radius);
        // }

        function getRadiusAtHeight(coneGeometry, pointInsideCone, conePosition) {
            // Ensure we are working with a ConeGeometry object
            if (!(coneGeometry instanceof THREE.ConeGeometry)) {
                throw new Error("Invalid geometry: expected THREE.ConeGeometry.");
            }

            // The height (h) and bottom radius (r) of the cone
            let h = coneGeometry.parameters.height;
            let r = coneGeometry.parameters.radius;


            // Adjust y to be relative to the cone's position
            let relativeY = pointInsideCone.y - conePosition.y;

            // Calculate the new radius at the pointInsideCone's adjusted y position
            let radiusAtY = r * ((h - relativeY) / h);

            return radiusAtY;
        }

        function localToWorld(conePosition, coneQuaternion, localPosition) {
            // Convert local position to world position
            const worldPosition = localPosition.clone();
            worldPosition.applyQuaternion(coneQuaternion);
            worldPosition.add(conePosition);
            return worldPosition;
        }


        function makeTree(x = 0, y = 0, _radius = null, _height = null, num_conf = 100, rotSpeed = null) {

            var confettiVelocities = [];
            var confettiAngles = [];
            let radius = _radius || Math.random() * 5 + 5;
            let height = _height || Math.random() * radius * 2 + 5;
            let scale = 0.5;
            let yPos = y + height * 4;
            let num_confetti = num_conf;

            const geometry = new THREE.ConeGeometry(radius, height, 32);
            const material = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, // Color can be set to white for a clear glass effect
                metalness: 0,   // Glass is non-metallic
                roughness: 0,   // Smooth glass surface has no roughness
                transmission: 1, // Transmission controls the transparency - 1 for full glass effect
                transparent: true,
                reflectivity: 1, // This can also affect the glass-like appearance
                ior: 1.5, // Index of refraction for glass-like materials, around 1.5 for glass
                // side: THREE.DoubleSide, // Render both sides of the material
                envMapIntensity: 5, // Intensity of the environment map
                clearcoat: 1, // Use clearcoat for a glossy finish
                clearcoatRoughness: 0 // Smooth clearcoat surface
            });

            // basic material
            // const material = new THREE.MeshPhysicalMaterial({
            //     color: 0xffffff, // Base color; individual colors will be set per instance.
            //     vertexColors: true, // Allow per-instance coloring.
            // });
            const cone = new THREE.Mesh(geometry, material);
            cone.receiveShadow = false; //default

            cone.position.set(x, y + height / 2, 0);

            scene.add(cone);

            const color = new THREE.Color();
            const colors = [];
            for (let j = 0; j < num_confetti; j++) {
                color.setHex(Math.random() * 0x808080 + 0x808080);
                colors.push(color.r, color.g, color.b); // Flatten the color values directly into the array
            }

            const confettiMaterial = new THREE.MeshBasicMaterial({});

            // Create a Float32BufferAttribute to hold the colors for the instances
            const colorAttribute = new THREE.InstancedBufferAttribute(new Float32Array(colors), 3);


            const confettiGeometry = new THREE.BoxGeometry(0.02 * 10, 0.001, 0.04 * 10);
            const confettiMesh = new THREE.InstancedMesh(confettiGeometry, confettiMaterial, num_confetti);

            confettiMesh.geometry.setAttribute('color', colorAttribute);
            confettiMaterial.vertexColors = true;

            // add additional properties
            confettiMesh.rotationSpeed = rotSpeed ? new THREE.Vector3(rotSpeed, rotSpeed, rotSpeed) : new THREE.Vector3(Math.random() * 0.01, Math.random() * 0.01, Math.random() * 0.01);
            confettiMesh.angleOffset = new THREE.Vector3(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

            // We need a dummy object to compute each instance's transformation matrix.
            const dummy = new THREE.Object3D();
            for (let j = 0; j < num_confetti; j++) {
                // Random position each confetti piece; for example within the cone volume.
                const point_in_cone = getRandomPositionInCone(cone.geometry, cone.position);
                point_in_cone.x += cone.position.x;
                point_in_cone.y += cone.position.y - height / 2;
                point_in_cone.z += cone.position.z;

                // We assign the position directly to dummy.position (as a Vector3)
                dummy.position.set(point_in_cone.x, point_in_cone.y, point_in_cone.z);

                // Random rotation
                dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                dummy.updateMatrix();

                // Set matrix at index j
                confettiMesh.setMatrixAt(j, dummy.matrix);

                const velocity = new THREE.Vector3(Math.random() * 5, Math.random() * 5, Math.random() * 5);
                confettiVelocities.push(velocity);

                const angle = new THREE.Vector3(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                confettiAngles.push(angle);
            }

            // Since we're working with the instances' matrices, the position for confettiMesh (as a whole) is a little different.
            confettiMesh.position.set(0, 0, 0);
            // confettiMesh.scale.set(scale * 1.55, scale * 1.55, scale * 1.55);
            // confettiMesh.castShadow = true; //default is false
            // confettiMesh.receiveShadow = true; //default
            // confettiMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // will be updated every frame
            // confettiMesh.instanceColor.setUsage(THREE.DynamicDrawUsage); // will be updated every frame

            // After all instances have been created, we need to call instanceMatrix.needsUpdate
            confettiMesh.instanceMatrix.needsUpdate = true;

            // Optional: Update the colors if they change.
            // confettiMesh.instanceColor.needsUpdate = true;

            scene.add(confettiMesh);

            return [cone, confettiMesh, confettiVelocities, confettiAngles];
        }
    </script>
    <script>
        let scene, camera, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, rotateLeft = false, rotateRight = false;
        let rise = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const speed = .5; // units per second
        const rotSpeed = 0.03; // radians per frame
        const clock = new THREE.Clock();

        // Set up the scene
        scene = new THREE.Scene();

        // Add perspective camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5.410454135560342, 3, 41.240690009835085);

        // Create WebGL Renderer
        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.gammaOutput = true;
        renderer.gammaFactor = 2.2; // adjust to your needs
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add a plane to represent a grassy plain
        const planeGeometry = new THREE.PlaneGeometry(100, 100, 32, 32);
        const planeMaterial = new THREE.MeshPhysicalMaterial({ color: 0xeeeeee });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2; // rotate the plane to lie flat
        plane.receiveShadow = true; // enable shadows on the plane
        scene.add(plane);

        // Add skybox skyblue color
        scene.background = new THREE.Color(0x777777);

        // Add lighting
        const light = new THREE.DirectionalLight(0xffffff, 10);
        light.position.set(0, 20, 0);
        light.castShadow = true; // default false
        scene.add(light);

        // ambient
        const ambientLight = new THREE.AmbientLight(0x404040, 10); // soft white light
        scene.add(ambientLight);

        // Create the objects
        let dummy = new THREE.Object3D();
        let confettis = [];
        let angles = [];
        let cones = [];

        let tree1 = makeTree(5, 5, 10, 15, 1000, .005); // all_confetti should be an InstancedMesh we've created above
        let cone1 = tree1[0];
        let confettiMesh1 = tree1[1];
        let confettiVelocities1 = tree1[2];
        let confettiAngles1 = tree1[3];

        let tree2 = makeTree(5, 15, 6, 10, 700, .0025); // all_confetti should be an InstancedMesh we've created above
        let cone2 = tree2[0];
        let confettiMesh2 = tree2[1];
        let confettiVelocities2 = tree2[2];
        let confettiAngles2 = tree2[3];

        let tree3 = makeTree(5, 22, 3, 5, 300, .002); // all_confetti should be an InstancedMesh we've created above
        let cone3 = tree3[0];
        let confettiMesh3 = tree3[1];
        let confettiVelocities3 = tree3[2];
        let confettiAngles3 = tree3[3];

        let tree4 = makeTree(5, 26, 1.5, 3, 100, .001); // all_confetti should be an InstancedMesh we've created above
        let cone4 = tree4[0];
        let confettiMesh4 = tree4[1];
        let confettiVelocities4 = tree4[2];
        let confettiAngles4 = tree4[3];

        confettis.push(confettiMesh1, confettiMesh2, confettiMesh3);
        angles.push(confettiAngles1, confettiAngles2, confettiAngles3);
        cones.push(cone1, cone2, cone3);


        // add a simple cylinder as a trunk
        const trunkGeometry = new THREE.CylinderGeometry(3.5, 3.5, 5, 32);
        const trunkMaterial = new THREE.MeshPhysicalMaterial({ color: 0xC0C0C0 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.set(5, 2.5, 0);
        // trunk.castShadow = true; // default false
        // trunk.receiveShadow = true; // default
        scene.add(trunk);

        // Star Topper
        // Create a star shape
        const starShape = new THREE.Shape();

        // Constants for star creation
        const outerRadius = 1; // Outer radius of the star points
        const innerRadius = .5; // Inner radius (between star points)
        const numPoints = 6; // Number of points in a star

        // Calculate the inner and outer angle increments
        const angleIncrement = Math.PI / numPoints;
        const innerAngleIncrement = angleIncrement;
        const outerAngleIncrement = angleIncrement * 2;

        // Start at the top of the star
        let currentAngle = -Math.PI / 2;
        let x, y;

        for (let i = 0; i < numPoints; i++) {
            // Draw line from inner to outer point
            x = Math.cos(currentAngle) * outerRadius;
            y = Math.sin(currentAngle) * outerRadius;
            if (i === 0) {
                starShape.moveTo(x, y);
            } else {
                starShape.lineTo(x, y);
            }

            // Increment the angle to draw the next point
            currentAngle += innerAngleIncrement;

            // Calculate position for the inner point
            x = Math.cos(currentAngle) * innerRadius;
            y = Math.sin(currentAngle) * innerRadius;
            starShape.lineTo(x, y);

            // Increment the angle to draw the next outer point
            currentAngle += outerAngleIncrement;
        }

        // Close the path of the star shape
        starShape.lineTo(0, -outerRadius);

        // Extrude the star shape to give it 3D volume; you can skip extrusion if you want a flat star
        const extrudeSettings = { depth: 1, bevelEnabled: false };
        const starGeometry = new THREE.ExtrudeGeometry(starShape, extrudeSettings);

        // Create a material for the star
        const starMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, // Color can be set to white for a clear glass effect
                metalness: 0,   // Glass is non-metallic
                roughness: 0,   // Smooth glass surface has no roughness
                transmission: 1, // Transmission controls the transparency - 1 for full glass effect
                transparent: true,
                reflectivity: 1, // This can also affect the glass-like appearance
                ior: 1.5, // Index of refraction for glass-like materials, around 1.5 for glass
                // side: THREE.DoubleSide, // Render both sides of the material
                envMapIntensity: 5, // Intensity of the environment map
                clearcoat: 1, // Use clearcoat for a glossy finish
                clearcoatRoughness: 0 // Smooth clearcoat surface
            });

        // Create a mesh from the geometry and material
        const starMesh = new THREE.Mesh(starGeometry, starMaterial);

        // Position the star on top of the tree
        starMesh.position.set(5, 30, 0);

        // Add it to the scene
        scene.add(starMesh);


        let cv = new THREE.Vector3(0, 0.01, 0);
        let color = new THREE.Color();
        // Animation loop
        const animate = function () {
            requestAnimationFrame(animate);

            const delta = clock.getDelta(); // Get the time between frames
            updateControls(delta); // Update the controls, if you have controls

            // update confetti
            let position = new THREE.Vector3();
            let quaternion = new THREE.Quaternion();
            let scale = new THREE.Vector3();

            // Add flow movement
            for (let i = 0; i < confettis.length; i++) {
                let confettiMesh = confettis[i];
                let cone = cones[i];
                // console.log(confettiMesh);
                for (let j = 0; j < confettiMesh.count; j++) {
                    confettiMesh.getMatrixAt(j, dummy.matrix);
                    dummy.matrix.decompose(position, quaternion, scale);

                    // Calculate the new position
                    angles[i][j].x += confettiMesh.rotationSpeed.x * 5.2;
                    // let radiusAtHeight = getRadiusAtHeight(position.y, cone.geometry);
                    // position.x = cone.position.x + radiusAtHeight * Math.cos(angles[i][j].x) * Math.cos(angles[i][j].y)
                    // position.z = cone.position.z + radiusAtHeight * Math.sin(angles[i][j].x) * Math.cos(angles[i][j].y);

                    let radiusAtHeight = getRadiusAtHeight(cone.geometry, position, cone.position);
                    position.x = cone.position.x + radiusAtHeight / 2 * Math.cos(angles[i][j].x) * Math.cos(angles[i][j].y);
                    position.z = cone.position.z + radiusAtHeight / 2 * Math.sin(angles[i][j].x) * Math.cos(angles[i][j].y);
                    // position.x = cone.position.x + radiusAtHeight * Math.cos(angles[i][j].x) * Math.cos(angles[i][j].y)
                    // position.z = cone.position.z + radiusAtHeight * Math.sin(angles[i][j].x) * Math.cos(angles[i][j].y);
                    dummy.matrix.compose(position, quaternion, scale);
                    confettiMesh.setMatrixAt(j, dummy.matrix);

                    // Set color for each instance
                    // confettiMesh.setColorAt(j, new THREE.Color(Math.random(), Math.random(), Math.random()));
                }

                confettiMesh.instanceMatrix.needsUpdate = true;
            }
            renderer.render(scene, camera);
        };

        // Handler for key down
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'KeyQ':
                    rotateLeft = true;
                    break;
                case 'KeyE':
                    rotateRight = true;
                    break;
                case 'Space':
                    rise = true;
                    break;
            }
        }, false);

        // Handler for key up
        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'KeyQ':
                    rotateLeft = false;
                    break;
                case 'KeyE':
                    rotateRight = false;
                    break;
                case 'Space':
                    rise = false;
                    break;

            }
        }, false);

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Update controls
        function updateControls(delta) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = -Number(moveRight) - -Number(moveLeft);
            direction.normalize(); // this ensures consistent movements in all directions

            if (moveForward || moveBackward) velocity.z -= direction.z * 1000.0 * delta * speed;
            if (moveLeft || moveRight) velocity.x -= direction.x * 1000.0 * delta * speed;
            if (rotateLeft) camera.rotation.y += rotSpeed;
            if (rotateRight) camera.rotation.y -= rotSpeed;
            if (rise) camera.position.y += 0.1;

            camera.translateX(velocity.x * delta);
            camera.translateZ(velocity.z * delta);

        }

        // Start the animation loop
        animate();

    </script>
</body>

</html>