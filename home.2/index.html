
<html>

<head>
    <title>Three.js Plane and Box</title>
    <style>
        body {
            margin: 0;
        }

        /* canvas { width: 100%; height: 100% } */
    </style>
</head>

<body>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@latest/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
          }
        }
      </script>
    <script type="module">
        import * as THREE from 'three';
        import { FlyControls } from 'three/addons/controls/FlyControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        var width = window.innerWidth;
        var height = window.innerHeight;
        // keyboard camera controls
        var keyboard = {};

        // Create a renderer
        var renderer = new THREE.WebGLRenderer();

        ////////////////////////////////
        // Create a scene
        var scene = new THREE.Scene();

        // Create a camera
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);

        // Skybox gradient from black to light blue
        const skyColor = new THREE.Color(0x000000);  // black
        const groundColor = new THREE.Color(0x87CEEB);  // light blue
        const intensity = 1;
        const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                skyColor: { value: groundColor },
                groundColor: { value: skyColor },
                intensity: { value: intensity }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 skyColor;
                uniform vec3 groundColor;
                uniform float intensity;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + vec3(0, 1, 0)).y;
                    gl_FragColor = vec4(mix(groundColor, skyColor, max(pow(max(h, 0.0), intensity), 0.0)), 1.0);
                }
            `,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        renderer.shadowMap.enabled = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create a plane with sin/cos vertices
        var planeGeometry = new THREE.PlaneGeometry(10, 10, 10, 10);
        // Modify vertices with sin/cos
        const vertices = planeGeometry.getAttribute('position');
        const count = vertices.count;
        const amplitude = 2;
        for (let i = 0; i < count; i++) {
            const x = vertices.getX(i);
            const y = vertices.getY(i);
            vertices.setXY(i, x + Math.sin(i) * amplitude, y + Math.cos(i) * amplitude);
        }
        planeGeometry.computeVertexNormals(); // Necessary to update normals after changing vertices
        var planeMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, side: THREE.DoubleSide, wireframe: true });
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.position.x = 0;
        plane.position.y = 0;
        plane.position.z = -planeGeometry.parameters.height;
        // scene.add(plane);


        var groundGeometry = new THREE.BoxGeometry(1000, 2, 1000);
        var groundMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color(26 / 255, 187 / 255, 51 / 255) });
        var ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.position.x = 0;
        ground.position.y = -planeGeometry.parameters.height;
        ground.position.z = 0
        // ground.rotation.x = Math.PI / 2;
        ground.receiveShadow = true;
        // ground.castShadow = true;
        scene.add(ground);

        // Create the Sun sphere
        var sunGeometry = new THREE.SphereGeometry(150, 32, 32);
        var sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffd65b, fog: false });
        var sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.x = 0;
        sun.position.y = -500
        sun.position.z = 400;
        // sun.receiveShadow = true;
        // sun.castShadow = true;
        scene.add(sun);

        // Create the light source
        // var light = new THREE.PointLight(0xffffff, 2, 3000, .001);
        var light = new THREE.SpotLight(0xffffff, 1, 2000, 1, 0, 0);
        light.target.position.set(0, 0, 0);
        light.position.set(0, 15, -200);
        light.castShadow = true;
        light.shadow.camera.near = 0.1;
        light.shadow.camera.far = 4000;
        light.shadow.camera.fov = 10;
        light.shadow.mapSize.width = 20024;
        light.shadow.mapSize.height = 20024;

        scene.add(light);

        // Adjust fog settings to prevent seeing through it
        scene.fog = new THREE.FogExp2(0x000000, 0.0005);

        // var hlight = new THREE.HemisphereLight(new THREE.Color(78 / 255, 140 / 255, 255 / 255), new THREE.Color(0, 0, 0), 1);
        // scene.add(hlight);


        // Create a test object in front of the camera to cast shadow
        // var testGeometry = new THREE.BoxGeometry(10, 10, 10);
        // var testMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        // var test = new THREE.Mesh(testGeometry, testMaterial);
        // test.position.x = 0;
        // test.position.y = 5;
        // test.position.z = -30;
        // test.castShadow = true;
        // test.receiveShadow = true;
        // scene.add(test);



        // font loader
        const loader = new FontLoader();
        
        // Retrieve the JSON font file
        loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/fonts/helvetiker_regular.typeface.json', function (font) {
            start(font);
        });

        function randomColor() {
            return Math.floor(Math.random() * 16777215);
        }

        function start(font) {

            // Add text to the front of the box
            var textGeometry = new TextGeometry('Hello World!', {
                font: font,
                size: 10,
                height: 1,
                curveSegments: 12,
            });

            // var textMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            var textMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0, // Make the surface completely smooth for maximum shininess
                clearcoat: 1, // Add a clear coat layer for additional shininess
                clearcoatRoughness: 0, // Ensure the clear coat layer is also completely smooth
                reflectivity: 1, // Maximize reflectivity
                transmission: 0, // No transmission since we want to reflect not transmit
                opacity: 1, // Fully opaque
                // wireframe: true, // No wireframe, we want a solid shiny surface
            });

            var text = new THREE.Mesh(textGeometry, textMaterial);
            // Scale the text down based on the computed width
            textGeometry.computeBoundingBox();
            text.position.x = -textGeometry.boundingBox.max.x / 2;
            text.position.z = -50;
            text.position.y = 10;
            // text.receiveShadow = true;
            text.castShadow = true;
            scene.add(text);
            animate();
        }

        // Resizing the canvas when the window is resized
        window.addEventListener('resize', function () {
            width = window.innerWidth;
            height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
        window.addEventListener('keydown', function (event) {
            keyboard[event.keyCode] = true;
        });
        window.addEventListener('keyup', function (event) {
            keyboard[event.keyCode] = false;
        });

        var pausesun = false;
        function moveCamera() {
            var cameraMoveSpeed = 4; // Configurable camera movement speed
            if (keyboard[87]) { // W key
                camera.position.z -= cameraMoveSpeed;
            }
            if (keyboard[83]) { // S key
                camera.position.z += cameraMoveSpeed;
            }
            if (keyboard[65]) { // A key
                camera.position.x -= cameraMoveSpeed;
            }
            if (keyboard[68]) { // D key
                camera.position.x += cameraMoveSpeed;
            }
            if (keyboard[81]) { // Q key
                camera.rotation.y += 0.05;
            }
            if (keyboard[69]) { // E key
                camera.rotation.y -= 0.05;
            }
            if (keyboard[32]) { // SPACE key
                camera.position.y += cameraMoveSpeed;
            }
            if (keyboard[16]) { // SHIFT key
                camera.position.y -= cameraMoveSpeed;
            }

            // 1 key
            if (keyboard[49]) {
                pausesun = !pausesun;
                keyboard[49] = false;
            }
        }

        // Animation function
        function animate() {
            requestAnimationFrame(animate);
            moveCamera();

            // Map the sun position to the mouse position
            document.addEventListener('mousemove', function (event) {
                var mouseX = (event.clientX / window.innerWidth);
                var mouseY = -(event.clientY / window.innerHeight);
                sun.position.x = mouseX * 700;
                sun.position.y = mouseY * 700;
            });

            if (!pausesun) {
                light.position.x = sun.position.x;
                light.position.y = sun.position.y;
                light.position.z = sun.position.z;

                // move the light to a point 100 units away from its current position relative to the center 0, 0, 0
                light.position.x += 100;
                light.position.y += 100;
                light.position.z += 100;

                // set the hemisphere sky color to reflect the sun's position
                scene.background = new THREE.Color(78 / 255 * (sun.position.y / 700), 140 / 255 * (sun.position.y / 700), 255 / 255 * (sun.position.y / 700));
            }

            renderer.render(scene, camera);
        }
    </script>
</body>

</html>