
<html>

<head>
    <title>Three.js Plane and Box</title>
    <style>
        body {
            margin: 0;
        }

        /* canvas { width: 100%; height: 100% } */
    </style>
</head>

<body>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@latest/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
          }
        }
      </script>
    <script type="module">
        import * as THREE from 'three';
        import { FlyControls } from 'three/addons/controls/FlyControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        var width = window.innerWidth;
        var height = window.innerHeight;
        // keyboard camera controls
        var keyboard = {};

        // Create a renderer
        var renderer = new THREE.WebGLRenderer();

        ////////////////////////////////
        // Create a scene
        var scene = new THREE.Scene();

        // Create a camera
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);

        // // Skybox gradient from black to light blue
        // const skyColor = new THREE.Color(0x000000);  // black
        // const groundColor = new THREE.Color(0x87CEEB);  // light blue
        // const intensity = 1;
        // const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
        // const skyMaterial = new THREE.ShaderMaterial({
        //     uniforms: {
        //         skyColor: { value: groundColor },
        //         groundColor: { value: skyColor },
        //         intensity: { value: intensity }
        //     },
        //     vertexShader: `
        //         varying vec3 vWorldPosition;
        //         void main() {
        //             vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        //             vWorldPosition = worldPosition.xyz;
        //             gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        //         }
        //     `,
        //     fragmentShader: `
        //         uniform vec3 skyColor;
        //         uniform vec3 groundColor;
        //         uniform float intensity;
        //         varying vec3 vWorldPosition;
        //         void main() {
        //             float h = normalize(vWorldPosition + vec3(0, 1, 0)).y;
        //             gl_FragColor = vec4(mix(groundColor, skyColor, max(pow(max(h, 0.0), intensity), 0.0)), 1.0);
        //         }
        //     `,
        //     side: THREE.BackSide
        // });
        // const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        // scene.add(sky);

        renderer.shadowMap.enabled = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create a plane with sin/cos vertices
        var planeGeometry = new THREE.PlaneGeometry(10, 10, 10, 10);
        // Modify vertices with sin/cos
        const vertices = planeGeometry.getAttribute('position');
        const count = vertices.count;
        const amplitude = 2;
        for (let i = 0; i < count; i++) {
            const x = vertices.getX(i);
            const y = vertices.getY(i);
            vertices.setXY(i, x + Math.sin(i) * amplitude, y + Math.cos(i) * amplitude);
        }
        planeGeometry.computeVertexNormals(); // Necessary to update normals after changing vertices
        var planeMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, side: THREE.DoubleSide, wireframe: true });
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.position.x = 0;
        plane.position.y = 0;
        plane.position.z = -planeGeometry.parameters.height;
        // scene.add(plane);


        var groundGeometry = new THREE.BoxGeometry(1000, 2, 1000);
        var groundMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color(26 / 255, 187 / 255, 51 / 255) });
        var ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.position.x = 0;
        ground.position.y = -planeGeometry.parameters.height;
        ground.position.z = 0
        // ground.rotation.x = Math.PI / 2;
        ground.receiveShadow = true;
        // ground.castShadow = true;
        scene.add(ground);

        // Create the Sun sphere
        var sunGeometry = new THREE.SphereGeometry(150, 32, 32);
        var sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffd65b, fog: false });
        var sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.x = 0;
        sun.position.y = 500;
        sun.position.z = 400;
        // sun.receiveShadow = true;
        // sun.castShadow = true;
        scene.add(sun);

        // Create the light source
        var light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 500, 400);
        light.castShadow = true;
        light.shadow.camera.left = -200;
        light.shadow.camera.right = 200;
        light.shadow.camera.top = 200;
        light.shadow.camera.bottom = -200;
        light.shadow.camera.near = 0.5;
        light.shadow.camera.far = 1500;
        light.shadow.mapSize.width = 14096; // Increased map size for better shadow resolution
        light.shadow.mapSize.height = 14096; // Increased map size for better shadow resolution

        scene.add(light);

        // put a soft point light near the camera
        var light2 = new THREE.PointLight(0xffffff, 1, 1000, .001); // list params: color, intensity, distance, decay
        light2.position.set(0, 4, 0);
        light2.castShadow = true;
        light2.intensity = 0;
        scene.add(light2);

        // Adjust fog settings to prevent seeing through it
        scene.fog = new THREE.FogExp2(0x000000, 0.0005);


        // Create 100 randomly sized/positioned boxes within a 10x10x10 area around 0x0x0
        for (let i = 0; i < 100; i++) {
            let boxGeometry = new THREE.BoxGeometry(
                Math.random(),
                Math.random(),
                Math.random()
            );
            let boxMaterial = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff });
            let box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.x = (Math.random() - 0.5) * 20;
            box.position.y = (Math.random() - 0.5) * 20;
            box.position.z = (Math.random() - 0.5) * 20;
            box.castShadow = true;
            box.receiveShadow = true;
            scene.add(box);
        }


        // font loader
        const loader = new FontLoader();
        
        // Retrieve the JSON font file
        loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/fonts/helvetiker_regular.typeface.json', function (font) {
            
            addText(font);
            start();
        });

        function randomColor() {
            return Math.floor(Math.random() * 16777215);
        }

        function addText(font) {
            
            let content = `
             RAU
            `;
            // Add text to the front of the box
            var textGeometry = new TextGeometry(content, {
                font: font,
                size: 10,
                height: 1,
                curveSegments: 12,
            });

            // var textMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            var textMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0, // Make the surface completely smooth for maximum shininess
                clearcoat: 1, // Add a clear coat layer for additional shininess
                clearcoatRoughness: 0, // Ensure the clear coat layer is also completely smooth
                reflectivity: 1, // Maximize reflectivity
                transmission: 0, // No transmission since we want to reflect not transmit
                opacity: 1, // Fully opaque
                // wireframe: true, // No wireframe, we want a solid shiny surface
            });

            var text = new THREE.Mesh(textGeometry, textMaterial);
            // Scale the text down and set position a little right of center of the screen
            textGeometry.computeBoundingBox();
            text.position.x = -textGeometry.boundingBox.max.x / 2 + 5; // Adjusted to be slightly right of center
            text.position.z = -50;
            text.position.y = 10;
            // text.receiveShadow = true;
            text.castShadow = true;
            scene.add(text);
        }

        function start() {
            animate();
        }

        // Resizing the canvas when the window is resized
        window.addEventListener('resize', function () {
            width = window.innerWidth;
            height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
        window.addEventListener('keydown', function (event) {
            keyboard[event.keyCode] = true;
        });
        window.addEventListener('keyup', function (event) {
            keyboard[event.keyCode] = false;
        });

        var pausesun = false;
        function moveCamera() {
            var cameraMoveSpeed = 4; // Configurable camera movement speed
            if (keyboard[87]) { // W key
                camera.position.z -= cameraMoveSpeed;
            }
            if (keyboard[83]) { // S key
                camera.position.z += cameraMoveSpeed;
            }
            if (keyboard[65]) { // A key
                camera.position.x -= cameraMoveSpeed;
            }
            if (keyboard[68]) { // D key
                camera.position.x += cameraMoveSpeed;
            }
            if (keyboard[81]) { // Q key
                camera.rotation.y += 0.05;
            }
            if (keyboard[69]) { // E key
                camera.rotation.y -= 0.05;
            }
            if (keyboard[32]) { // SPACE key
                camera.position.y += cameraMoveSpeed;
            }
            if (keyboard[16]) { // SHIFT key
                camera.position.y -= cameraMoveSpeed;
            }

            // 1 key
            if (keyboard[49]) {
                pausesun = !pausesun;
                keyboard[49] = false;
            }
        }

        // Animation function
        function animate() {
            requestAnimationFrame(animate);
            moveCamera();

            if (!pausesun) {
                light.position.x = sun.position.x;
                light.position.y = sun.position.y;
                light.position.z = sun.position.z;

                // move the light to a point 100 units away from its current position relative to the center 0, 0, 0
                light.position.x += 100;
                light.position.y += 100;
                light.position.z += 100;

                // turn off the light if its under the ground
                if (light.position.y < 0) {
                    light.intensity = 0;
                    light2.intensity = 1;
                } else {
                    light.intensity = 1;
                    light2.intensity = 0;
                }

                // set light color to reflect the sun's position
                light.color = new THREE.Color(255 / 255 * (sun.position.y / 700), 214 / 255 * (sun.position.y / 700), 91 / 255 * (sun.position.y / 700));

                // update sun position in a circular path using sine and cosine
                var angle = performance.now() * -0.0001;
                sun.position.x = 500 * Math.sin(angle);
                sun.position.y = 500 * Math.cos(angle);
                sun.position.z = 400;

                // set the hemisphere sky color to reflect the sun's position
                scene.background = new THREE.Color(78 / 255 * (sun.position.y / 700), 140 / 255 * (sun.position.y / 700), 255 / 255 * (sun.position.y / 700));
            }

            renderer.render(scene, camera);
        }
    </script>
</body>

</html>